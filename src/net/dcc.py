"""
    support for dcc chat, send, get

    This implementation is slighly based on Twisted's protocol.irc.dcc* stuff

"""

# $Id: dcc.py,v 1.13 2002/02/27 18:28:41 ivo Exp $

import struct

from twisted.protocols import basic, protocol
from util.debug import debug, DEBUG

#
# 3 soorten dcc: dcc send, dcc get en dcc chat
# dcc chat kan geinitieerd of accepted worden
#
#
# handle nick!user@host
# track nickchanges? (perhaps do this in dccquery?)
class dcc_chat(basic.LineReceiver):
    """ is \n or \r\n standard? ircii accepts \r"""
    def __init__(self, handler, clientdata=None):
        """
            handler is an object that can handle events generated by this
            protocol (base class should probably be defined)

            clientdata is optional data that will be passed to generated
            events
        """
        basic.LineReceiver.delimiter = "\n"
        self.clientdata = clientdata
        self.handler = handler

    def connectionFailed(self):
        self.handler.dcc_connectionFailed(self.clientdata)

    def connectionLost(self):
        self.handler.dcc_connectionLost(self.clientdata)

    def connectionMade(self):
        self.handler.dcc_connectionMade(self.clientdata)

    def lineReceived(self, line):
        if line[-1] == '\r':
            line = line[:-1]
        self.handler.dcc_lineReceived(line, self.clientdata)

    def send(self, line):
        print "SEND", self, self.transport
        self.transport.write("%s\n" % line)

##
## We will want to show progression somehow to the handler
class dcc_fileoffer(protocol.Protocol):
    """
        TODO: powersend (mirc compatible) - don't check acks
              dcc resume
              security checks

    """

    def __init__(self, handler, clientdata=None):
        self.clientdata = clientdata
        self.handler = handler
        self.sentbytes = 0

    def connectionMade(self):
        # in powermode we need to install a producer to continuously feed data
        # (withouth regard for the acks sent by the other party)
        self.sendBlock()

    def dataReceived(self, data):
        remote_bytes = struct.unpack("!I", data)[0]
        if remote_bytes < self.sentbytes:
            # wait..
            return
        elif remote_bytes > self.sentbytes:
            print "DCC out of sync", remote_bytes, self.sentbytes
            self.transport.loseConnection()

        self.sendBlock()

    def sendBlock(self):
        """ send a new block of data """
        block = self.handler.getBlock(self.clientdata)
        if block:
            self.transport.write(block)
            self.sentbytes = self.sentbytes + len(block)
            print "New block sent, ", self.sentbytes
        else:
            self.transport.loseConnection()

    ##
    ## producer related methods
    def resumeProducing(self):
        pass

    def pauseProducing(self):
        pass

    def stopProducing(self):
        pass

class dcc_filereceipt(protocol.Protocol):
    """
    """
    def __init__(self, handler, clientdata=None):
        self.clientdata = clientdata
        self.handler = handler
        self.receivedbytes = 0

    def connectionMade(self):
        # self.transport.registerProducer(self)
        pass

    def connectionLost(self):
        self.handler.dcc_connectionLost(self.clientdata)

    def dataReceived(self, data):
        print "Data received"
        self.receivedbytes = self.receivedbytes + len(data)
        self.transport.write(struct.pack("!I", self.receivedbytes))
        ##
        ## pass self as well (everywhere!)
        self.handler.dcc_dataReceived(data, self.clientdata)
    

